import{_ as a,o as e,c as t,Q as r}from"./chunks/framework.b72fc385.js";const i="/mfapp/guide/1.png",b=JSON.parse('{"title":"概述","description":"","frontmatter":{},"headers":[],"relativePath":"guide/index.md","filePath":"guide/index.md","lastUpdated":1697386468000}'),l={name:"guide/index.md"},o=r('<h1 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h1><h2 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h2><blockquote><p>微前端官网：<a href="https://micro-frontends.org/" target="_blank" rel="noreferrer">https://micro-frontends.org/</a></p></blockquote><p>问题：如何实现多个应用之间的资源共享？</p><p>之前比较多的处理方式是npm包形式抽离和引用，比如多个应用项目之间，可能有某业务逻辑模块或其他是可复用的，便抽离出来以npm包的形式进行管理和使用。但这样却带来了以下几个问题：</p><ul><li>发布效率低下：如果需要迭代npm包内的逻辑业务，需要先发布npm包之后，再每个使用了该npm包的应用都更新一次npm包版本，再各自构建发布一次，过程繁琐。如果涉及到的应用更多的话，花费的人力和精力就更多了。</li><li>多团队协作容易不规范：包含通用模块的npm包作为共享资产，每个人拥有它，但在实践中，这通常意味着没有人拥有它，它很快就会充满杂乱的风格不一致的代码，没有明确的约定或技术愿景。</li></ul><p>这些问题让我们意识到，扩展前端开发规模以便多个团队可以同时开发一个大型且复杂的产品是一个重要但又棘手的难题。因此，早在2016年，微前端概念诞生了。</p><h2 id="微前端概念" tabindex="-1">微前端概念 <a class="header-anchor" href="#微前端概念" aria-label="Permalink to &quot;微前端概念&quot;">​</a></h2><p>“微前端”一词最早于 2016 年底在 ThoughtWorks Technology Radar 中提出，它将后端的微服务概念扩展到了前端世界。微服务是服务端提出的一个有界上下文、松耦合的架构模式，具体是将应用的服务端拆分成更小的微服务，这些微服务都能独立运行，采用轻量级的通信方式（比如 HTTP ）。</p><p>微前端概念的提出可以借助下面的 Web 应用架构模式演变图来理解。</p><p><img src="'+i+'" alt=""></p><p>最原始的架构模式是单体 Web 应用，整个应用由一个团队来负责开发。</p><p>随着技术的发展，开发职责开始细分，一个项目的负责团队会分化成前端团队和后端团队，即出现了前后端分离的架构方式。</p><p>随着项目变得越来越复杂，先感受到压力的是后端，于是微服务的架构模式开始出现。</p><p>随着前端运行环境进一步提升，Web 应用的发展趋势越来越倾向于富应用，即在浏览器端集成更多的功能，前端层的代码量以及业务逻辑也开始快速增长，从而变得越来越难以维护。于是引入了微服务的架构思想，将网站或 Web 应用按照业务拆分成粒度更小的微应用，由独立的团队负责开发。</p><p>从图上可以看出，微前端、微服务这些架构模式的演变趋势就是不断地将逻辑进行拆分，从而降低项目复杂度，提升可维护性和可复用性。</p><p>所以说微前端是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户看来仍然是内聚的单个产品。有一个基座应用（主应用），来管理各个子应用的加载和卸载。</p><h2 id="微前端的优势" tabindex="-1">微前端的优势： <a class="header-anchor" href="#微前端的优势" aria-label="Permalink to &quot;微前端的优势：&quot;">​</a></h2><h3 id="同步更新" tabindex="-1">同步更新 <a class="header-anchor" href="#同步更新" aria-label="Permalink to &quot;同步更新&quot;">​</a></h3><p>对比npm包方式抽离，让我们意识到更新流程和效率的重要性，微前端由于是多个子应用的聚合，如果多个业务应用依赖同一个服务应用的功能模块，只需要更新服务应用，其他业务应用就可以立马更新，从而缩短了更新流程和节约了更新成本。</p><h3 id="增量升级" tabindex="-1">增量升级 <a class="header-anchor" href="#增量升级" aria-label="Permalink to &quot;增量升级&quot;">​</a></h3><p>迁移是一项非常耗时且艰难的任务，比如有一个管理系统使用AngularJS开发维护已经有三年时间，但是随着时间的推移和团队成员的变更，无论从开发成本还是用人需求上，AngularJS已经不能满足要求，于是团队想要更新技术栈，想在其他框架中实现新的需求，但是现有项目怎么办？直接迁移是不可能的，在新的框架中完全重写也不太现实。</p><p>使用微前端架构就可以解决问题，在保留原有项目的同时，可以完全使用新的框架开发新的需求，然后再使用微前端架构将旧的项目和新的项目进行整合，这样既可以使产品得到更好的用户体验，也可以使团队成员在技术上得到进步，产品开发成本也降到的最低。</p><h3 id="独立部署与发布" tabindex="-1">独立部署与发布 <a class="header-anchor" href="#独立部署与发布" aria-label="Permalink to &quot;独立部署与发布&quot;">​</a></h3><p>在目前的单页应用架构中，使用组件构建用户界面，应用中的每个组件或功能开发完成或者bug修复完成后，每次都需要对整个产品重新进行构建和发布，任务耗时操作上也比较繁琐。</p><p>在使用了微前端架构后，可以将不能的功能模块拆分成独立的应用，此时功能模块就可以单独构建单独发布了，构建时间也会变得非常快，应用发布后不需要更改其他内容应用就会自动更新，这意味着你可以进行频繁的构建发布操作了。</p><h3 id="独立团队决策" tabindex="-1">独立团队决策 <a class="header-anchor" href="#独立团队决策" aria-label="Permalink to &quot;独立团队决策&quot;">​</a></h3><p>因为微前端架构与框架无关，当一个应用由多个团队进行开发时，每个团队都可以使用自己擅长的技术栈进行开发，也就是它允许适当的让团队决策使用哪种技术，从而使团队协作变得不再僵硬。</p><h2 id="基座" tabindex="-1">基座 <a class="header-anchor" href="#基座" aria-label="Permalink to &quot;基座&quot;">​</a></h2><p>基座是微前端应用集成的一个重要平台。同时也肩负着管理公共资源、依赖、规范的责任。</p><p>基座主要功能：</p><ul><li>子应用集成, 给子应用提供渲染容器</li><li>路由/菜单管理</li><li>权限管理</li><li>主题管理</li><li>会话管理</li><li>多语言管理</li><li>共享依赖</li></ul>',32),n=[o];function p(h,d,s,c,u,m){return e(),t("div",null,n)}const f=a(l,[["render",p]]);export{b as __pageData,f as default};
